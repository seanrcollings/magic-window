import asyncio
from .. import con as con
from .._private import (
    EventType as EventType,
    MessageType as MessageType,
    PubSub as PubSub,
    Synchronizer as Synchronizer,
)
from ..events import (
    BarconfigUpdateEvent as BarconfigUpdateEvent,
    BindingEvent as BindingEvent,
    Event as Event,
    InputEvent as InputEvent,
    IpcBaseEvent as IpcBaseEvent,
    ModeEvent as ModeEvent,
    OutputEvent as OutputEvent,
    ShutdownEvent as ShutdownEvent,
    TickEvent as TickEvent,
    WindowEvent as WindowEvent,
    WorkspaceEvent as WorkspaceEvent,
)
from ..replies import (
    BarConfigReply as BarConfigReply,
    CommandReply as CommandReply,
    ConfigReply as ConfigReply,
    InputReply as InputReply,
    OutputReply as OutputReply,
    SeatReply as SeatReply,
    TickReply as TickReply,
    VersionReply as VersionReply,
    WorkspaceReply as WorkspaceReply,
)
from typing import Any, Callable, List, Optional, Union, Coroutine

class _AIOPubSub(PubSub):
    def queue_handler(self, handler: Any, data: Optional[Any] = ...) -> None: ...
    def emit(self, event: Any, data: Any) -> None: ...

class Con(con.Con):
    async def command(self, command: str) -> List[CommandReply]: ...  # type: ignore
    async def command_children(self, command: str) -> List[CommandReply]: ...  # type: ignore

class Connection:
    def __init__(
        self, socket_path: Optional[str] = ..., auto_reconnect: bool = ...
    ) -> None: ...
    @property
    def socket_path(self) -> str: ...
    @property
    def auto_reconect(self) -> bool: ...
    async def connect(self) -> Connection: ...
    async def subscribe(
        self, events: Union[List[Event], List[str]], force: bool = ...
    ) -> Any: ...
    def on(
        self,
        event: Union[Event, str],
        handler: Callable[[Connection, IpcBaseEvent], None],
    ) -> Any: ...
    def off(self, handler: Callable[[Connection, IpcBaseEvent], None]) -> Any: ...
    async def command(self, cmd: str) -> List[CommandReply]: ...
    async def get_version(self) -> VersionReply: ...
    async def get_bar_config_list(self) -> List[str]: ...
    async def get_bar_config(self, bar_id: Any = ...) -> Optional[BarConfigReply]: ...
    async def get_outputs(self) -> List[OutputReply]: ...
    async def get_workspaces(self) -> List[WorkspaceReply]: ...
    async def get_tree(self) -> Con: ...
    async def get_marks(self) -> List[str]: ...
    async def get_binding_modes(self) -> List[str]: ...
    async def get_config(self) -> ConfigReply: ...
    async def send_tick(self, payload: str = ...) -> TickReply: ...
    async def get_inputs(self) -> List[InputReply]: ...
    async def get_seats(self) -> List[SeatReply]: ...
    def main_quit(self, _error: Optional[Any] = ...) -> None: ...
    async def main(self) -> None: ...
